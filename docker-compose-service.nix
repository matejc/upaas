{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.docker-compose;

  manifestFile = { outPath = cfg.manifest; name = "manifest.json"; };
  manifest = builtins.fromJSON (builtins.readFile manifestFile);

  runServiceFun = name: yml:
  {
    description = "docker-compose ${name}";
    wantedBy = [ "multi-user.target" ];
    after = [ "network.target" "docker.service" ];
    requires = [ "docker.service" ];
    path = [ pkgs.docker pkgs.python27Packages.docker_compose ];
    serviceConfig = {
      ExecStart = "${pkgs.python27Packages.docker_compose}/bin/docker-compose -p '${name}' -f '${yml}' up";
      KillSignal   = "SIGINT";
      TimeoutStopSec = "20";
      Type = "simple";
    };
  };

  runServices = optionalAttrs (builtins.pathExists cfg.manifest)
    (builtins.listToAttrs (
      map (v: nameValuePair ("docker-compose-" + v.name) (runServiceFun v.name v.yml)) manifest
    ));

  buildCompose = pkgs.writeScriptBin "docker-compose-build" ''
    #!/usr/bin/env bash
    ${pkgs.nix}/bin/nix-shell default.nix --argstr outFile '${cfg.manifest}'
  '';
in

{
  options = {
    services.docker-compose = {
      enable = mkOption {
        default = false;
        type = types.bool;
        description = ''
          Enable docker-compose.
        '';
      };
      manifest = mkOption {
        type = types.either types.string types.path;
        default = "/var/docker-compose/manifest.json";
        description = ''
          Manifest file generated by `docker-compose-build` command.
        '';
      };
    };
  };

  config = mkIf cfg.enable ({
    systemd.services = runServices;
    environment.systemPackages = [ buildCompose ];
  });
}
